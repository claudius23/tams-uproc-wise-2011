\documentclass{article}
\usepackage[utf8x]{inputenc}
\usepackage{fontenc}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{longtable}
\usepackage[usenames,dvipsnames]{color}

\lstset{
  numbers=left,
  frame=leftline,
  breaklines=true,
  keywordstyle=\color{Blue},
  identifierstyle=\color{Green}
}

\newcommand{\cpu}{processor}

\author{Claudius, Irina, Justus, Paul}
\title{\cpu\\
tams-uproc-wise-2011}
\date{\today}

\begin{document}

\maketitle
\newpage

\tableofcontents
\newpage

\section{Instruction set architecture}

\subsection{Data types}

The \cpu uses a word size of 32 bit. All integers are interpreted as
signed, encoded using the two's complement. The word ordering is big
endian.

\subsection{Registers}

There are 32 registers. The first 24 are general purpose registers,
the last eight serve a special role. Each register can be manipulated
using all the instructions that utilize a register.

Each special register has a symbolic name, given in square brackets in
the table below.

\begin{center}
  \begin{tabular}{l|l}
    Register & \\
    \hline
    \%0 - \%23   & general purpose register \\
    \%24 [\%ac]  & accumulator \\
    \%25 [\%pl]  & procedure linkage table \\
    \%26 [\%lr]  & link register \\
    \%27 [\%bp]  & base pointer \\
    \%28 [\%sp]  & stack pointer \\
    \%29 [\%st]  & status register \\
    \%30 [\%pc]  & program counter. The highest bit must be set to 0. \\
    \%31 [\_]    & zero register. Reading from \%31 yields zero, \\
                 & writing to it is ignored. \\
  \end{tabular}
\end{center}

\subsubsection{The status register \%st}
\begin{center}
  \begin{tabular}{l|l}
    Bit    & Description \\
    \hline
    31 - 4 & reserved \\
    3      & management mode \\
    2      & arithmetic instruction resulted in signed overflow \\
    1      & arithmetic instructions result was negative \\
    0      & arithmetic instructions result was zero \\
  \end{tabular}
\end{center}

\subsection{Instruction encoding}

The instruction width is four bytes, the first one (i.e. bits 31-24)
encodes the opcode, the others are used to encode parameters.

\subsection{Opcodes}

\begin{center}
  \begin{tabular}{c|l}
    Bit & \\
    \hline
    7 - 3  & Instruction selector. \\
    3      & Arithmetic instructions only: Denotes that the status \\
           & register should be updated. \\
    2 - 0  & Conditional selector. \\
  \end{tabular}
\end{center}

\section{Application binary interface}

\subsection{Calling convention}

\newcommand{\I}[1]{\emph{#1}}

Function calls are implemented using the synthetic \I{call}
instruction. \I{call Reg0} is equivalent to \I{br \%lr, Reg0, \_,
  0}. \I{br} stores the return address \(\%pc + 4\) into \I{\%lr}.

The registers \(\%0 - \%7\) are used to hand parameters to the callee,
serve as scratch registers for the callee and can be used to return
values to the caller.

The caller must consider those registers dirty after a function call.
The callee can choose to hand results back to the caller.

TODO: push more arguments to the stack

\subsection{Function prologue}

\begin{lstlisting}
function_start:    push %pl, %lr, %bp, %st
                   mov %bp, %sp
\end{lstlisting}

\subsection{Function epilogue}

\begin{lstlisting}
                   mov %sp, %bp
                   pop %sp, %bp, %lr, %pl
                   ret
\end{lstlisting}

\appendix
\section{\appendixname}

\subsection{List of opcodes}
\include{opcodes}

\end{document}
